线程调度实习报告
  ------------------

[*内容一：总体概述* ](#内容一总体概述)

[*内容二：任务完成情况* ](#内容二任务完成情况)

[*任务完成列表（Y/N）* ](#任务完成列表yn)

[*具体Exercise的完成情况* ](#具体exercise的完成情况)

[*内容三：遇到的困难以及解决方法* ](#内容三遇到的困难以及解决方法)

[*内容四：收获及感想* ](#内容四收获及感想)

[*内容五：对课程的意见和建议* ](#内容五对课程的意见和建议)

[*内容六：参考文献* ](#内容六参考文献)

## 内容一：总体概述

本次Lab主要通过修改nachos底层源代码，来考察对**优先级、时间片轮转和多级反馈队列等重要调度思想**的理解，对**Timer、Scheduler和Interrupt等文件关系**的理解，以及**时间中断的产生和处理机制**的理解。本次Lab是整个nachos的重中之重，对其理解程度直接决定了未来Lab的完成程度。

## 内容二：任务完成情况

### 任务完成列表（Y/N）

|          | Exercise1 | Exercise2 | Exercise3 | Challenge1 |
| -------- | --------- | --------- | --------- | ---------- |
| 第一部分 | Y         | Y         | Y         | Y          |



### 具体Exercise的完成情况

#### 第一部分

**Exercise1**

**调研Linux或Windows中采用的进程/线程调度算法。具体内容见课堂要求。**



Linux的内核有三种调度策略：SCHED\_OTHER分时调度策略，SCHED\_FIFO实时调度策略（先到先服务），SCHED\_RR实时调度策略（时间片轮转）。

RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。

当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。

RR进程和FIFO进程都采用实时优先级做为调度的权值标准，RR是FIFO的一个延伸。FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的位置决定的，这样导致一些不公正性，如果将两个优先级一样的任务的调度策略都设为RR，则保证了这两个任务可以循环执行，保证了公平。

Linux内核将进程分成两个级别：普通进程和实时进程。实时进程的优先级都高于普通进，除此之外，它们的调度策略也有所不同。

如果一个进程有实时需求（它是一个实时进程），则只要它是可执行状态的，内核就一直让它执行，以尽可能地满足它对CPU的需求，直到它完成所需要做的事情，然后睡眠或退出（变成非可执行状态）。而如果有多个实时进程都处于可执行状态，则内核会先满足优先级最高的实时进程对CPU的需要，直到它变为非课执行状态。于是，只要有高优先级的实时进程一直处于可执行状态，低优先级的实时进程就一直不能得到CPU；只要一直有实时进程处于可执行状态，普通进程就一直不能得到CPU。后来内核进行了一些改动，限定了以sched\_rt\_period\_us为周期的时间内，实时进程最多只能运行sched\_rt\_runtime\_us这样给普通进程留下了一点点能够得到执行的机会。

**Exercise2**

**仔细阅读下列源代码，理解Nachos现有的线程调度算法。**

-   **code/threads/scheduler.h和code/threads/scheduler.cc**

-   **code/threads/switch.s**

-   **code/machine/timer.h和code/machine/timer.cc**


.


-   **scheduler.h和scheduler.cc**

> scheduler.h中定义了scheduler类，是nachos中的进程调度器，通过FIFO进行调度。scheduler的成员函数的具体实现位于scheduler.cc中。
>
> 在scheduler类中，定义了以下函数，用以进行线程调度：
>
> 1.  **void ReadyToRun(Thread\* thread);** 将一个线程的状态置为READY，并将其放入就绪队列readyList中
>
> 2.  **Thread\* FindNextToRun(int source);** 从就绪队列中取出下一个上CPU的线程。
>
> 3.  **void Run(Thread\* nextThread);** 真正进行线程调度，保存当前的机器信息，然后将nextThread替换上CPU。
>

-   **switch.s**

> switch.s内容是汇编代码，负责CPU上进程的切换。
>
> 切换过程中，首先保存当前进程的状态，然后回复新运行进程的状态，之后切换到新进程的栈空间，开始运行新进程。

-   **timer.h和timer.cc**

> 这一部分定义并实现了Timer类，用以模拟硬件的时间中断。通过分析Timer类的定义可以初步了解时间模块的运行原理：
>
> 1.  **Timer(VoidFunctionPtr timerHandler, int callArg, bool doRandom)**；初始化这个模拟时钟。参数timerHandler表示时钟中断处理函数，callArg是timerHandler函数的参数，doRandom表示是否允许中断随机发生，而不是预先制定好。变量初始化完成后，该函数把一个时钟中断插入等待处理的中断队列，当时钟中断时刻到来时，调用TimerHandler函数，调用它的TimerExpired方法，该方法将新的时钟中断插入等待处理中断队列中，然后再调用真正的时钟中断处理函数。
>
> 2.  **TimerExpired()**；该函数将新的时钟中断插入等待处理中断队列中，然后再调用真正的时钟中断处理函数，这样Nachos就可以定时收到时钟中断。
>
> 3.  **TimerOfNextInterrupt()**；该函数返回距离下一次中断发生所需要的时钟周期数。
>



**Exercise3**

**扩展线程调度算法，实现基于优先级的抢占式调度算法。**



首先在Thread类中添加一个priority的属性，取值范围0\~8，数值越小，优先级越高，默认优先级为8。

在基于优先级的抢占式调度算法下，线程的切换时机有以下两个：

-   一个新的线程被创建，而且其优先级高于当前正在运行的线程

-   当前线程结束生命周期，主动让出CPU

对于第二种情况，当前线程会调用已有的Finish()方法，主动从就绪队列中挑选下一个线程运行，无需修改。

而第一种情况，高优先级的线程被创建后，会被调用ReadyToRun()放到就绪队列。而如果采用基于优先级的抢占式调度，那么该线程被放入就绪队列中后应该立刻发生线程切换，高优先级线程获得CPU。因此，应该修改ReadyToRun()，在新创建线程被放入就绪队列后，应该额外比较该线程和正在运行的线程的优先级，如果该线程的优先级较高，则其获得CPU。

除此之外，将线程放入就绪队列也应该采用优先级由高到低的次序排列，此时可以使用List的sortedInsert()插入方法。

测试程序：线程执行一个循环，在循环中创建一个比自己优先级高的线程。例如，main线程创建优先级为5的线程，优先级为5的线程再创建优先级为2的线程。实验结果如下：

<img src="..\images\Lab2线程调度\e3-1.png" style="zoom:80%;" />

<img src="..\images\Lab2线程调度\e3-2.png" style="zoom:80%;" />

<img src="..\images\Lab2线程调度\e3-3.png" style="zoom:80%;" />



**Challenge1**

***时间片轮转算法：***



设计思路：每个线程都应该拥有一个变量来记录自身已使用的时间片长度，时间中断每次触发时都会检查当前运行线程的时间片是否已用完，如果用完，则引起线程调度。

Thread：在Thread类中增加一个usedTimeSlice的变量，记录线程已使用的时间片长度，并在线程切换相关函数中，维护该变量，例如，线程重新获得CPU时，usedTimeSlice清零。

时间中断：在时间中断处理函数中，添加一个判断条件，如果当前运行线程的时间片已用完，则调用interrupt-&gt;YieldOnReturn()，这样在OneTick()中就会试当前线程主动调用currentThread-&gt;Yield()让出CPU，切换进程。

因为OneTick()不建议直接调用，因此为了在进程运行时模拟时间前进，则在进程中主动开关中断以模拟。编写测试程序，有3个线程，其需要的运行时间分别为60，20，40，各运行一个循环，循环每进行一次，所需一个SystemTick（10），线程拥有时间片TimerSlice（20）。

<img src="..\images\Lab2线程调度\c1-1.png" style="zoom:80%;" />

<img src="..\images\Lab2线程调度\c1-2.png" style="zoom:80%;" />

<img src="..\images\Lab2线程调度\c1-3.png" style="zoom:80%;" />

<img src="..\images\Lab2线程调度\c1-4.png" style="zoom:80%;" />



***多级队列反馈调度算法：***

多级队列反馈调度算法实际上就是将优先级算法和时间片轮转结合起来，但需要改变的地方有：

-   优先级部分：将本来作为线程成员变量的优先级priority改成了线程所在等待队列的级数，为了方便实验现象的分析，我假设多级队列一共有两个。

-   时间片轮转部分：设第二级队列分配的时间片是第一级队列的两倍。

将基于优先级的抢占式调度算法和时间片轮转算法的代码合并，在此基础上仍需修改的部分：

-   Thread：

> 1.  增加一个变量，用于描述线程的状态——刚刚创建，位于第一级队列还是第二级队列，方便后面函数根据线程状态，做出不同的决策。
>
> 2.  增加时间片最大长度的变量，并且增加片段已使用的时间是否大于时间片长度的函数，用于判断时间是否到了。
>
> 3.  在Yield()中设置将要退出CPU的线程2倍的时间片（因为既然调用了Yield()，则不论其当前在何队列，一定会放入到第二级队列）， currentThread-&gt;setMaxTimeSlice(2\*TimerSlice);
>

-   Schedule：

> 1.  再增加一个readyList2，第二级等待队列。
>
> 2.  ReadyToRun()中根据线程的状态，如果是刚刚创建，则放入readyList，并将线程状态更改为第一级队列；如果是第一级或第二级队列，则放入readyList2；如果是第一级，则再将线程状态更改为第二级。
>
> 3.  FindNextToRun()中首先从readyList中寻找下一个线程，如果没有找到，则从readyList2中寻找。
>

测试程序部分：与时间片轮转算法中的测试程序相似，只是线程的所需时间变为了100，40，60。结果如下图：

<img src="..\images\Lab2线程调度\c2-1.png" style="zoom:80%;" />



## 内容三：遇到的困难以及解决方法

#### 困难1

一开始没有想明白nachos到底是如何模拟时钟中断的，因为在学习理论知识时，OS的时间中断是由硬件装置触发，操作系统处理。结果现在，nachos本身时作为宿主OS（Ubuntu）的一个用户级应用程序，因此想要在nachos中真正模拟时钟前进触发中断，感觉很不现实。但这只是我自己的分析，我仍旧没有看明白到底是怎么模拟的，我创建的线程在运行期间到底是由谁来负责计时的？

无奈，我只好花了一整天，将相关文件从头到尾，包括所有的注释全部都认真阅读了一遍，加上长时间在头脑中的模拟流程，重要让我想明白了！

因此我收获了经验，在做实验之前，最好还是先将有可能涉及到的文件阅读一遍，在真正明白了之后再做题，效果会更好。而不是看完题，盯着各文件中代码发呆，一遍又一遍的切换着文件，结果是没有一个文件完整地阅读完毕理解明白。

## 内容四：收获及感想

在本实验中，我充分利用了Git的强大功能，在Lab1代码的基础上，创建了master（priority）、timer和multi三个分支，先在master做优先级抢占算法，做完之后push到github上，然后checkout切换到timer分支上，做时间片轮转，然后push；最后切换到multi，做多级队列反馈算法，push。以上都是在Ubuntu虚拟机上完成的，我在自己的Windos上clone我自己的github仓库，在3个分支之间切换，分别打成压缩包当作作业提交。

使用版本控制工具真是太方便了。

我的github仓库：https://github.com/wuhao9714/myNachos3.4

## 内容五：对课程的意见和建议

提交完作业后，最好能在上课时抽出一些时间讲一讲。

## 内容六：参考文献

\[1\]佚名 Nachos中文教程

http://wenku.baidu.com/link?url=1rGnypg8Hq6-43gAvuIYPWyVlPLZ0S\_XNEXQJ-2ShqPPg3n2bqWvQgRYC8PdVXLmr66e9GpC2nCSbE1ofkgcT6aASWqVklMWUaBuZNSmXDy
