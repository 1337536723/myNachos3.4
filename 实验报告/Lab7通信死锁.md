通信死锁实习报告
  ------------------

[*内容一：总体概述* ](#内容一总体概述)

[*内容二：任务完成情况* ](#内容二任务完成情况)

[*任务完成列表（Y/N）* ](#任务完成列表yn)

[*具体Exercise的完成情况* ](#具体exercise的完成情况)

[*内容三：遇到的困难以及解决方法* ](#内容三遇到的困难以及解决方法)

[*内容四：收获及感想* ](#内容四收获及感想)

[*内容五：对课程的意见和建议* ](#内容五对课程的意见和建议)

[*内容六：参考文献* ](#内容六参考文献)

## 内容一：总体概述

认识Linux中进程的通信机制，并选择其中的一种机制，在Nachos上实现。进一步扩展对Nachos同步互斥机制的了解和使用，作为同步互斥的扩展，实现死锁的模拟、检测和预防等算法。

## 内容二：任务完成情况

### 任务完成列表（Y/N）

|          | Exercise1 | Exercise2 | Exercise3 |
| -------- | --------- | --------- | --------- |
| 第一部分 | Y         | Y         | Y         |
| 第二部分 | Y         |           |           |

​                  

### 具体Exercise的完成情况

#### 第一部分 通信机制

**Exercise1 调研Linux中进程通信机制的实现**



Linux下进程间通信的几种主要手段：

- 管道(Pipe)及有名管道(named pipe),具有以下特点：
  - 管道是半双工的,数据只能向一个方向流动;需要双方通信时,需要建立起两个管道;

  - 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

  - 单独构成一种独立的文件系统:管道对于管道两端的进程而言,就是一个文件,但它不是普通的文件,它不属于某种文件系统,而是自立门户,单独构成一种文件系统,并且只存在于内存中。

  - 数据的读出和写入:一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾,并且每次都是从缓冲区的头部读出数据。

- 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
- 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
- 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。



**Exercise2 为Nachos设计并实现一种线程/进程间通信机制**

**基于已完善的线程、调度、同步机制部分，选择Linux中的一种进程通信机制，在Nachos上实现**。



我选择实现的是消息队列机制。主要思想是建立一个全局消息数组，发送和接收消息的进程均在该数组中进行消息的传递。

首先在thread.h中定义消息体的结构:valid用来表示该位置的消息是否有效，destination表示接收该消息的线程id，content是消息的内容，count是content中实际消息的长度（包括‘\\0’）。

<img src="..\images\Lab7通信死锁\e2-1.png" style="zoom:80%;" />

在system.cc中定义Message messages\[MaxMessage\];消息数组，并在Initialize中完成其初始化——valid置为FALSE，这里MaxMessage表示消息队列的最大长度。

为每个线程增添Send和Receive两个函数。Send将要传递的消息和接收进程id放入消息队列中空闲的位置。函数体内首先判断content的有效性：count的实际内容（不包含‘\\0’）必须大于0且小于MaxContent。其次循环判断消息队列中是否有空闲位置，如果有，则将第一个空闲位valid置为TRUE，并将其它相关信息拷贝到该空闲位的对应位置；否则，返回FALSE。Receive则遍历整个消息队列，寻找有效且接收进程为自己的消息体。

<img src="..\images\Lab7通信死锁\e2-2.png" style="zoom:80%;" />

<img src="..\images\Lab7通信死锁\e2-3.png" style="zoom:80%;" />



**Exercise3 为实现的通信机制编写测试用例**



首先编写测试指令，nachos -m message, 修改main函数体，调用MessageTest函数，message为参数。测试程序如下：主线程创建forked线程，并发送message给forked线程；而forked线程接收该消息。

<img src="..\images\Lab7通信死锁\e3-1.png" style="zoom:80%;" />

测试结果如下：

<img src="..\images\Lab7通信死锁\e3-1.png" style="zoom:80%;" />



#### 第二部分 死锁

**Exercise1 死锁检测和预防**

**可以使用Nachos 提供的同步互斥机制（如条件变量）来：模拟死锁的发生、对系统中存在的死锁进行检测、在分配不可共享资源时，增加死锁预防算法。**



**模拟死锁的发生：**

死锁最简单的一种形式，是由于两个进程均占有对方继续运行下去所必需的资源，从而双方永远无法运行下去。设置测试程序前，实现基于优先级的调度算法，该算法已在Lab2线程调度中实现。这里我们使用信号量来模拟资源。设置r1和r2两个独占资源，主线程先获取r1，然后创建优先级更高fork线程，然后获取r2；fork线程先获取r2，然后获取r1。此时死锁发生，由于两个线程均为阻塞状态，从而系统中再无可运行的线程，nachos停机。测试程序及运行结果如下图所示：

<img src="..\images\Lab7通信死锁\2e1-1.png" style="zoom:80%;" />

**对系统中存在的死锁进行检测：**

首先当系统中存在死锁时，必须有线程能够运行某种算法来检测当前是否存在死锁。所以这里设置一个优先级最低的线程——平衡集管理器，并假设该优先级只有其自身，在创建main线程后就紧接着创建。当就绪队列中没有可运行的程序时，该线程就会变为运行态，调用死锁检测算法。这里，为了简化问题，设置一个全局变量记录处于阻塞状态的线程数，每当一个线程调用sleep变为阻塞态时就加一，当有线程被放入就绪队列时，如果其之前是阻塞态，则减一。根据死锁条件，如果该变量大于等于2，则说明系统中存在死锁。其余部分与前一问相同，测试结果如下：

<img src="..\images\Lab7通信死锁\2e1-2.png" style="zoom:80%;" />

**死锁预防：**

为了防止死锁的发生，必须破坏死锁的四个基本条件：资源互斥是资源使用的固有特性是无法改变的。则预防死锁的方法有如下三种：

1.  破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。

2.  破坏“请求与保持条件”：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。

3.  破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

这里我采用最容易实现的一次性申请方法，即线程一次性申请所有会用到的资源。那么在该种原则下，上述的死锁模拟情形便自动解除：死锁发生正是由于main线程在未申请到所有的资源且占有部分资源的情况下，便被其它线程抢占，这才导致死锁的发生。倘若main申请所有资源的部分设置为临界区，则死锁便不会发生。因此此算法的测试程序便是更改原有的测试流程，死锁模拟自然也就失效。

## 内容三：遇到的困难以及解决方法

#### 困难1

message结构体中消息的内容该如何定义。我参考网上的资料[*https://wenku.baidu.com/view/b4c693d1d05abe23482fb4daa58da0116c171f1e*](https://wenku.baidu.com/view/b4c693d1d05abe23482fb4daa58da0116c171f1e)该同学同样实现了消息队列，但他的message中的content是char\*类型的，而且在进程的send和receive的过程中都是直接赋值。我们知道在C语言中，指针是一把双刃剑，它灵活却又充满危险，许多程序的错误都是由于指针的误操作而导致的。发送消息的进程，其消息的来源可能有两种，一种是外部传递进来的，比如上面的测试程序；但更多的是第二种，即该进程自己产生的。那么该进程的消息如果通过send直接将指针赋值给message中的content，那么如果该进程在接收进程接收和使用该centent之前就消亡的话，那么该content指针也会同样变为NULL，此时，即便接收进程已经获取了content，使用时也会发生致命错误。那么为了防止这种情况，必须要保证message中的content是一个实体，因此我将其设置为char content\[MaxContent\]。虽然在Send和Receive时的操作变得繁琐，但至少保证的通信的安全性和正确性。

## 内容四：收获及感想

关于平衡集管理器，我实现的是将其设置为优先级最低的线程，当就绪队列没有其它线程时才会运行，但这其实与实际不符。更好的做法是，在Timer类的TimerExpired函数中，创建平衡集管理器，并将其优先级设置为最高。这样可以使得平衡集管理器每隔一段时间就会运行一次，且是强制性运行。

其次，死锁检测算法我有一个更好的思路，但是由于时间和能力等问题，暂时无法实现。我觉得可以创建一个资源管理数组，基本结构体为{线程指针，已占有资源数组，正在申请的资源}。这样每次平衡集管理器都可以扫描该数组，检测是否存在死锁闭环，这样就可以判断当前系统中是否有死锁发生。

## 内容五：对课程的意见和建议

作为最后一次的nachos实验，回顾这一学期，我觉得收获最大的并非是课堂，而是该实验。或许一个寒假之后，我的理论知识就忘得差不多了，但是我在nachos上亲自实现过的部分，却是我最难忘记的。建议以后的课程进一步加大nachos的占分比，同时老师在课上也应该有侧重地将理论知识和同时间进行的实验相结合。

毕竟，坚持选课且不退课的同学，没有人是奔着GPA来的，都是真正想学好OS的。

## 内容六：参考文献

*\[1\]深刻理解Linux进程间通信(IPC)-详解*

[**https://wenku.baidu.com/view/15b858c3e55c3b3567ec102de2bd960591c6d930.html**](https://wenku.baidu.com/view/15b858c3e55c3b3567ec102de2bd960591c6d930.html)

*\[2\]死锁的四个必要条件？如何避免与预防死锁？*

[**https://www.cnblogs.com/bopo/p/9228834.html\#\_label3\_1**](https://www.cnblogs.com/bopo/p/9228834.html#_label3_1)

*\[3\]nachos-Lab8实习报告*

[**https://wenku.baidu.com/view/b4c693d1d05abe23482fb4daa58da0116c171f1e**](https://wenku.baidu.com/view/b4c693d1d05abe23482fb4daa58da0116c171f1e)

*\[4\]陈老师上课课件和《现代操作系统》*
